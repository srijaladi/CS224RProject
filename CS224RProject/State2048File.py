import torchimport torch.nn as nnimport randomimport numpy as npclass State2048:    def __init__(self,version):        self.version = version        if self.version == "Log":            self.base = 1        elif self.version == "Reg":            self.base = 2        else:            print("VERSION MUST BE EITHER 'REG' OR 'LOG'")        def initialize_state(self):        state = np.zeros((4,4))        check = self.sample_n_locations_in_place(state, 2)        assert np.sum(state != 0) == 2        assert check        return state        def gen_new_number(self):        z = random.uniform(0,1)        if z > 0.1:            return self.base        else:            return self.increment_number(self.base)            def increment_number(self, num):        if self.version == "Reg":            return num * 2        elif self.version == "Log":            return num + 1        else:            print("VERSION MUST BE EITHER 'REG' OR 'LOG'")            def move_by_action(self, input_state: np.ndarray, action: int):        curr_state = np.copy(input_state)        done = [[0 for _ in range(4)] for _ in range(4)]        combines, combined_amt = 0, 0        if action == 0:            for c in range(4):                for r in range(1,4):                    num = curr_state[r,c]                    if num == 0: continue                    found = -1                    for j in range(r-1,-1,-1):                        if curr_state[j,c] != 0:                            found = j                            break                    if found < 0 or curr_state[found,c] != num or done[found][c]:                        curr_state[r,c] = 0                        curr_state[found+1,c] = num                    else:                        curr_state[r,c] = 0                        curr_state[found,c] = self.increment_number(curr_state[found,c])                        combined_amt += curr_state[found,c]                        combines += 1                        done[found][c] = 1        elif action == 1:            for r in range(4):                for c in range(2,-1,-1):                    num = curr_state[r,c]                    if num == 0: continue                    found = 4                    for j in range(c+1,4):                        if curr_state[r,j] != 0:                            found = j                            break                    if found > 3 or curr_state[r,found] != num or done[r][found]:                        curr_state[r,c] = 0                        curr_state[r,found-1] = num                    else:                        curr_state[r,c] = 0                        curr_state[r,found] = self.increment_number(curr_state[r,found])                        combined_amt += curr_state[found,c]                        combines += 1                        done[r][found] = 1        elif action == 2:            for c in range(4):                for r in range(2,-1,-1):                    num = curr_state[r,c]                    if num == 0: continue                    found = 4                    for j in range(r+1,4):                        if curr_state[j,c] != 0:                            found = j                            break                    if found > 3 or curr_state[found,c] != num or done[found][c]:                        curr_state[r,c] = 0                        curr_state[found-1,c] = num                    else:                        curr_state[r,c] = 0                        curr_state[found,c] = self.increment_number(curr_state[found,c])                        combined_amt += curr_state[found,c]                        combines += 1                        done[found][c] = 1        elif action == 3:            for r in range(4):                for c in range(1,4):                    num = curr_state[r,c]                    if num == 0: continue                    found = -1                    for j in range(c-1,-1,-1):                        if curr_state[r,j] != 0:                            found = j                            break                    if found < 0 or curr_state[r,found] != num or done[r][found]:                        curr_state[r,c] = 0                        curr_state[r,found+1] = num                    else:                        curr_state[r,c] = 0                        curr_state[r,found] = self.increment_number(curr_state[r,found])                        combined_amt += curr_state[found,c]                        combines += 1                        done[r][found] = 1        else:              print("ERROR INCORRECT INPUT ACTION")                return curr_state, combines, combined_amt        def transition(self, input_state, action: int):        if not(action in self.possible_actions(input_state)):            return input_state, True, False                new_state, combined_count, combined_amt = self.move_by_action(input_state, action)        if not(self.check_move_is_possible(new_state)):            return new_state, False, True        else:                        prev = np.sum(new_state != 0)            check = self.sample_n_locations_in_place(new_state, 1)            assert prev == 16 or prev + 1 == np.sum(new_state != 0)            assert check            return new_state, True, True            def check_move_is_possible(self, state):        for r in range(4):            for c in range(4):                if state[r][c] == 0:                    return True                if r+1 < 4 and state[r+1][c] == state[r][c]:                    return True                if c+1 < 4 and state[r][c+1] == state[r][c]:                    return True        return False        def used_spots(self, state):        return np.sum(state != 0)        def state_score(self, state, not_term, valid_move):        if not(valid_move):            return -2000        elif not(not_term):            return -1000        else:            count = np.sum(state != 0)            s = np.sum(state)            avg = s/count            return avg        def check_action_is_possible(self, state, action):        if action == 0:            for r in range(1,4):                for c in range(4):                    if state[r,c] != 0 and (state[r-1,c] == state[r,c] or state[r-1,c] == 0): return True        elif action == 1:            for r in range(4):                for c in range(3):                    if state[r,c] != 0 and (state[r,c+1] == state[r,c] or state[r,c+1] == 0): return True        elif action == 2:            for r in range(3):                for c in range(4):                    if state[r,c] != 0 and (state[r+1,c] == state[r,c] or state[r+1,c] == 0): return True        elif action == 3:            for r in range(4):                for c in range(1,4):                    if state[r,c] != 0 and (state[r,c-1] == state[r,c] or state[r,c-1] == 0): return True        else:            print("ERROR INCORRECT INPUT ACTION")        return False            def sample_n_locations_in_place(self, input_state, sample_count: int):        locations = [(i,j) for i in range(4) for j in range(4) if input_state[i,j] == 0]        if len(locations) == 0: return False        for sample_r, sample_c in random.sample(locations, sample_count):            input_state[sample_r,sample_c] = self.gen_new_number()        return True        def print_state(self, state):        for r in range(4):            for c in range(4):                print(int(state[r][c]), end = " ")            print()        def possible_actions(self, state):        return [i for i in range(4) if self.check_action_is_possible(state, i)]